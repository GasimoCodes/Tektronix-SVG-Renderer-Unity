#pragma kernel CSDrawLines

// Buffers
StructuredBuffer<float2> points; // List of all points
StructuredBuffer<int> path; // Indices of points forming the path
StructuredBuffer<float4> pointColors; // Colors for each point (optional)

// Parameters
int pointCount;
int currentLineIndex;
float lineWidthPixels;
float4 startColor;
float4 endColor;
float4 solidColor;
int useElementColors; // Whether to use element colors

// Output
RWTexture2D<float4> Result;

// Helper function for anti-aliased pixel intensity with nonlinear falloff
float PixelIntensity(float dist, float lineWidth)
{
    float halfWidth = lineWidth * 0.5;
    // Apply nonlinear falloff using exponential function
    float normalizedDist = saturate((dist - (halfWidth - 0.5)) / 1.0);
    return saturate(1.0 - pow(normalizedDist, 1.5)); // Nonlinear falloff power
}

// Helper function to ensure alpha is always 1.0
float4 EnsureOpaque(float4 color)
{
    return float4(color.rgb, 1.0);
}

// Helper function to get HDR intensity multiplier with nonlinear gradient
float GetHDRIntensity(int lineIndex, int currentIndex)
{
    // Create a nonlinear falloff for intensity
    float distance = currentIndex - lineIndex;
    
    if (distance <= 0)
        return 2.0; // Current line is brightest
    else if (distance < 15)
    {
        // Exponential falloff for more realistic phosphor persistence
        float normalizedDist = distance / 15.0;
        return 2.0 * pow(1.0 - normalizedDist, 2.2) + 0.8;
    }
    else
        return 0.8; // Base brightness for older lines
}

// Helper function to check if a color is black
bool IsBlack(float4 color)
{
    return color.r < 0.01 && color.g < 0.01 && color.b < 0.01;
}

// Helper function to create a subtle variation in shape for the drawing head
float2 VaryShape(float2 offset, float time, float strength)
{
    // Create a subtle organic variation using sin/cos
    float angle = atan2(offset.y, offset.x);
    float len = length(offset);
    
    // More natural shape variation based on time and angle
    float variation = sin(angle * 3.0 + time * 0.1) * 0.2 +
                      cos(angle * 2.0 + time * 0.2) * 0.3 +
                      sin(angle * 5.0 + time * 0.05) * 0.1; // Add higher frequency detail
    
    // Adjust length based on variation
    len *= 1.0 + variation * strength;
    
    // Convert back to cartesian coordinates
    return float2(cos(angle) * len, sin(angle) * len);
}

// Calculate phosphor color transition between segments
float4 GetPhosphorTransitionColor(float4 prevColor, float4 currentColor, float age, float t)
{
    // Apply nonlinear blending between the colors
    float blendPower = 1.5; // Controls nonlinearity of the transition
    float blendFactor = pow(t, blendPower);
    
    // Phosphors decay at different rates (green persists longer than blue, red in between)
    float3 decayRates = float3(0.85, 0.92, 0.75); // RGB decay rates
    float3 agingColor = lerp(currentColor.rgb, prevColor.rgb * decayRates, saturate(age * 0.5));
    
    return float4(agingColor, 1.0);
}

[numthreads(64, 1, 1)]
void CSDrawLines(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    
    // Skip if thread index is out of bounds
    if (idx >= currentLineIndex)
        return;
        
    int startIndex = path[idx];
    int endIndex = path[idx + 1];
    
    // Skip rendering if a break marker (-1) is encountered
    if (startIndex == -1 || endIndex == -1)
        return;
        
    // Get the points for this line segment
    float2 start = points[startIndex];
    float2 end = points[endIndex];
    
    // Skip invalid indices
    if (startIndex >= pointCount || endIndex >= pointCount)
        return;
    
    // Determine line properties
    float2 dir = end - start;
    float len = length(dir);
    
    // Skip if length is too small
    if (len < 0.001)
        return;
        
    dir = dir / len; // Normalize
    
    // Get segment color if enabled
    float4 segmentColor = float4(0, 0, 0, 1);
    bool useDefault = true;
    
    if (useElementColors > 0)
    {
        float4 pointStartColor = pointColors[startIndex];
        float4 pointEndColor = pointColors[endIndex];
        
        // Use point colors if not black (use average color if they differ)
        bool startIsBlack = IsBlack(pointStartColor);
        bool endIsBlack = IsBlack(pointEndColor);
        
        if (!startIsBlack || !endIsBlack)
        {
            if (!startIsBlack && !endIsBlack)
            {
                // Weighted average to improve color transitions
                segmentColor = lerp(pointStartColor, pointEndColor, 0.5);
            }
            else if (!startIsBlack)
            {
                segmentColor = pointStartColor;
            }
            else
            {
                segmentColor = pointEndColor;
            }
            useDefault = false;
        }
    }
    
    // Calculate normalized age for this line segment
    float age = saturate((float) (currentLineIndex - idx) / 15.0);
    float ageSquared = age * age; // Nonlinear age factor
    
    // Get previous segment color for smooth transitions between segments
    float4 prevLineColor = float4(0, 0, 0, 1);
    if (idx > 0 && idx < currentLineIndex)
    {
        // Try to get previous segment color
        int prevStartIndex = path[idx - 1];
        int prevEndIndex = path[idx];
        
        if (prevStartIndex >= 0 && prevEndIndex >= 0 && prevStartIndex < pointCount && prevEndIndex < pointCount)
        {
            if (useElementColors > 0)
            {
                float4 prevPointStartColor = pointColors[prevStartIndex];
                float4 prevPointEndColor = pointColors[prevEndIndex];
                
                bool prevStartIsBlack = IsBlack(prevPointStartColor);
                bool prevEndIsBlack = IsBlack(prevPointEndColor);
                
                if (!prevStartIsBlack || !prevEndIsBlack)
                {
                    if (!prevStartIsBlack && !prevEndIsBlack)
                    {
                        prevLineColor = lerp(prevPointStartColor, prevPointEndColor, 0.5);
                    }
                    else if (!prevStartIsBlack)
                    {
                        prevLineColor = prevPointStartColor;
                    }
                    else
                    {
                        prevLineColor = prevPointEndColor;
                    }
                }
            }
        }
    }
    
    // Determine the color for the line with nonlinear HDR intensity gradient
    float4 lineColor;
    float hdrIntensity = GetHDRIntensity(idx, currentLineIndex);
    
    if (useDefault)
    {
        // Use default colors with improved nonlinear gradient
        if (idx > currentLineIndex - 15)
        {
            // Newest lines get gradient colors with smoother nonlinear transition
            float t = (float) (currentLineIndex - idx) / 15.0;
            float tNonlinear = saturate(pow(t, 1.8)); // Nonlinear transition
            lineColor = lerp(startColor, endColor, tNonlinear) * hdrIntensity;
        }
        else
        {
            // Older lines get solid color
            lineColor = solidColor * hdrIntensity;
        }
    }
    else
    {
        // Use element color with appropriate intensity and improved gradient
        if (idx > currentLineIndex - 15)
        {
            lineColor = segmentColor * hdrIntensity * 1.2;
        }
        else
        {
            lineColor = segmentColor * hdrIntensity;
        }
    }
    
    // Blend with previous segment color for smoother transitions
    if (idx > 0 && idx < currentLineIndex - 1)
    {
        float transitionFactor = saturate(pow(0.7, idx % 3)); // Nonlinear transition between segments
        lineColor = lerp(lineColor, prevLineColor, transitionFactor * 0.3);
    }
    
    // Always ensure alpha is 1.0
    lineColor.a = 1.0;
    
    // Draw the line with adaptive step size
    float step = min(0.4, 0.8 / max(len, 1.0)); // Smaller steps for smoother rendering
    
    for (float t = 0.0; t <= 1.0; t += step)
    {
        float2 pos = lerp(start, end, t);
        int2 pixel = int2(pos);

        // Determine the color for the current position
        float4 interpolatedColor;
        if (idx == currentLineIndex - 1) // Only apply gradient to the most recent line
        {
            // Correct gradient direction with nonlinear interpolation
            float tNonlinear = pow(t, 1.2); // Nonlinear transition along the line
            interpolatedColor = lerp(endColor, startColor, tNonlinear) * hdrIntensity;
        }
        else
        {
            // Apply phosphor decay effect for older lines
            float segmentAge = age + (1.0 - t) * 0.05; // Slightly older at start of segment
            interpolatedColor = GetPhosphorTransitionColor(prevLineColor, lineColor, segmentAge, t);
        }

        // Increase drawing head size for the most recent line
        float headMultiplier = (idx == currentLineIndex - 1) ? 1.8 : 1.0;
        float effectiveLineWidth = lineWidthPixels * headMultiplier;
        
        // Calculate nonlinear width reduction for older lines
        if (idx < currentLineIndex - 1)
        {
            float widthDecay = pow(1.0 - age * 0.3, 1.5); // Nonlinear width decay
            effectiveLineWidth *= max(0.7, widthDecay);
        }
        
        // Draw with thickness and anti-aliasing
        float halfWidth = effectiveLineWidth * 0.5;
        int radius = int(ceil(halfWidth + 2.0)); // Increased radius for larger glow

        for (int dy = -radius; dy <= radius; dy++)
        {
            for (int dx = -radius; dx <= radius; dx++)
            {
                float2 offset = float2(dx, dy);
                
                // Apply subtle shape variation to the drawing head
                if (idx == currentLineIndex - 1)
                {
                    offset = VaryShape(offset, idx + t * 10.0, 0.18);
                }
                
                float dist = length(offset);
                float intensity = PixelIntensity(dist, effectiveLineWidth);

                // Enhanced nonlinear glow for the drawing head
                if (idx == currentLineIndex - 1)
                {
                    // Stronger glow effect with larger radius for the drawing head
                    float glowRadius = effectiveLineWidth + 4.0;
                    float glowFalloff = 2.2; // Higher value for more concentrated glow
                    float normalizedDist = saturate(dist / glowRadius);
                    float glowIntensity = saturate(pow(1.0 - normalizedDist, glowFalloff) * 0.8);
                    intensity = max(intensity, glowIntensity);
                }

                if (intensity > 0.005) // Lower threshold for subtle effects
                {
                    int2 drawPos = pixel + int2(offset);

                    // Get existing color for burn-in effect
                    float4 existingColor = Result[drawPos];
                    
                    // Apply nonlinear intensity curve
                    float adjustedIntensity = pow(intensity, 1.3);
                    float4 newColor = interpolatedColor * adjustedIntensity;

                    // Always ensure alpha is 1.0
                    newColor.a = 1.0;
                    existingColor.a = 1.0;

                    // Improved blending for drawing head and recent lines
                    if (idx == currentLineIndex - 1)
                    {
                        // Enhanced additive blending with HDR glow for drawing head
                        Result[drawPos] = float4(
                            max(existingColor.r, newColor.r * 1.3),
                            max(existingColor.g, newColor.g * 1.3),
                            max(existingColor.b, newColor.b * 1.3),
                            1.0
                        );
                    }
                    else
                    {
                        // Phosphor-like persistence with nonlinear blending
                        float persistence = saturate(1.0 - pow(age, 1.5)); // Nonlinear persistence
                        float blendFactor = lerp(0.97, 0.65, persistence);
                        
                        // Phosphor-specific color channels decay at different rates
                        float3 channelDecay = float3(0.98, 0.99, 0.96); // RGB persistence rates
                        float3 blendedColor = lerp(
                            existingColor.rgb * channelDecay,
                            newColor.rgb,
                            blendFactor * adjustedIntensity
                        );
                        
                        Result[drawPos] = float4(blendedColor, 1.0);
                    }
                }
            }
        }
    }
}
